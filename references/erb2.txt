{	comment = '
	TODO: unresolved issues

	text:
	"p <<end
	print me!
	end"
	symptoms:
	not recognized as a heredoc
	solution:
	there is no way to distinguish perfectly between the << operator and the start
	of a heredoc. Currently, we require assignment to recognize a heredoc. More
	refinement is possible.
	• Heredocs with indented terminators (<<-) are always distinguishable, however.
	• Nested heredocs are not really supportable at present

	text:
	print <<-''THERE'' 
	This is single quoted. 
	The above used #{Time.now} 
	THERE 
	symtoms:
	From Programming Ruby p306; should be a non-interpolated heredoc.
	
    text:
    val?(a):p(b)
    val?''a'':''b''
    symptoms:
    '':p'' is recognized as a symbol.. its 2 things '':'' and ''p''.
    :''b'' has same problem.
    solution:
    ternary operator rule, precedence stuff, symbol rule.
    but also consider ''a.b?(:c)'' ??
';
	patterns = (
		{	name = 'meta.class.ruby';
			match = '^\s*(class)\s+(?:([.a-zA-Z0-9_:]+)(?:\s*(<)\s*([.a-zA-Z0-9_:]+))?|(<<)\s*([.a-zA-Z0-9_:]+))';
			captures = {
				1 = { name = 'keyword.control.class.ruby'; };
				2 = { name = 'entity.name.type.class.ruby'; };
				3 = { name = 'keyword.operator.other.ruby'; };
				4 = { name = 'entity.other.inherited-class.ruby'; };
				5 = { name = 'keyword.operator.other.ruby'; };
				6 = { name = 'variable.other.object.ruby'; };
			};
		},
		{	name = 'meta.module.ruby';
			match = '^\s*(module)\s+(([A-Z]\w*(::))?([A-Z]\w*(::))?([A-Z]\w*(::))*[A-Z]\w*)';
			captures = {
				1 = { name = 'keyword.control.module.ruby'; };
				2 = { name = 'entity.name.type.module.ruby'; };
				3 = { name = 'entity.other.inherited-class.module.first.ruby'; };
				4 = { name = 'punctuation.separator.inheritance.ruby'; };
				5 = { name = 'entity.other.inherited-class.module.second.ruby'; };
				6 = { name = 'punctuation.separator.inheritance.ruby'; };
				7 = { name = 'entity.other.inherited-class.module.third.ruby'; };
				8 = { name = 'punctuation.separator.inheritance.ruby'; };
			};
		},
		{	name = 'invalid.deprecated.ruby';
			comment = 'else if is a common mistake carried over from other languages. it works if you put in a second end, but it’s never what you want.';
			match = '(?<!\.)\belse(\s)+if\b';
		},
		{	name = 'constant.other.symbol.hashkey.ruby';
			comment = 'symbols as hash key (1.9 syntax)';
			match = '(?>[a-zA-Z_]\w*(?>[?!])?)(:)(?!:)';
			captures = { 1 = { name = 'punctuation.definition.constant.ruby'; }; };
		},
		{	name = 'constant.other.symbol.hashkey.ruby';
			comment = 'symbols as hash key (1.8 syntax)';
			match = '(?<!:)(:)(?>[a-zA-Z_]\w*(?>[?!])?)(?=\s*=>)';
			captures = { 1 = { name = 'punctuation.definition.constant.ruby'; }; };
		},
		{	name = 'keyword.control.ruby';
			comment = "everything being a reserved word, not a value and needing a 'end' is a..";
			match = '(?<!\.)\b(BEGIN|begin|case|class|else|elsif|END|end|ensure|for|if|in|module|rescue|then|unless|until|when|while)\b(?![?!])';
		},
		{	name = 'keyword.control.start-block.ruby';
			comment = 'contextual smart pair support for block parameters';
			match = '(?<!\.)\bdo\b';
		},
		{	name = 'meta.syntax.ruby.start-block';
			comment = 'contextual smart pair support';
			match = '(?<=\{)(\s+)';
		},
		{	name = 'keyword.control.pseudo-method.ruby';
			match = '(?<!\.)\b(alias|alias_method|block_given[?]|break|defined[?]|iterator[?]|next|redo|retry|return|super|undef|yield)(\b|(?<=[?]))(?![?!])';
		},
		{	name = 'constant.language.ruby';
			match = '\b(nil|true|false)\b(?![?!])';
		},
		{	name = 'variable.language.ruby';
			match = '\b(__(dir|FILE|LINE)__)\b(?![?!])';
		},
		{	comment = '__END__ marker';
			begin = '^__END__\n';
			end = '(?=not)impossible';
			captures = { 0 = { name = 'string.unquoted.program-block.ruby'; }; };
			contentName = 'text.plain';
			patterns = (
				{	name = 'text.html.embedded.ruby';
					begin = '(?=<?xml|<(?i:html\b)|!DOCTYPE (?i:html\b))';
					end = '(?=not)impossible';
					patterns = ( { include = 'text.html.basic'; } );
				},
			);
		},
		{	name = 'variable.language.self.ruby';
			match = '\b(self)\b(?![?!])';
		},
		{	name = 'keyword.other.special-method.ruby';
			comment = ' everything being a method but having a special function is a..';
			match = '\b(initialize|new|loop|include|extend|prepend|fail|raise|attr_reader|attr_writer|attr_accessor|attr|catch|throw|private|private_class_method|module_function|public|public_class_method|protected|refine|using)\b(?![?!])';
		},
		{	name = 'meta.require.ruby';
			begin = '\b(?<!\.|::)(require|require_relative)\b';
			end = '$|(?=#|\})';
			captures = { 1 = { name = 'keyword.other.special-method.ruby'; }; };
			patterns = ( { include = '$self'; } );
		},
		{	name = 'variable.other.readwrite.instance.ruby';
			match = '(@)[a-zA-Z_]\w*';
			captures = { 1 = { name = 'punctuation.definition.variable.ruby'; }; };
		},
		{	name = 'variable.other.readwrite.class.ruby';
			match = '(@@)[a-zA-Z_]\w*';
			captures = { 1 = { name = 'punctuation.definition.variable.ruby'; }; };
		},
		{	name = 'variable.other.readwrite.global.ruby';
			match = '(\$)[a-zA-Z_]\w*';
			captures = { 1 = { name = 'punctuation.definition.variable.ruby'; }; };
		},
		{	name = 'variable.other.readwrite.global.pre-defined.ruby';
			match = '(\$)(!|@|&|`|''|\+|\d+|~|=|/|\\|,|;|\.|<|>|_|\*|\$|\?|:|"|-[0adFiIlpvw])';
			captures = { 1 = { name = 'punctuation.definition.variable.ruby'; }; };
		},
		{	name = 'meta.environment-variable.ruby';
			begin = '\b(ENV)\[';
			end = '\]';
			beginCaptures = { 1 = { name = 'variable.other.constant.ruby'; }; };
			patterns = ( { include = '$self'; } );
		},
		{	name = 'support.class.ruby';
			match = '\b[A-Z]\w*(?=((\.|::)[A-Za-z]|\[))';
		},
		{	name = 'support.function.kernel.ruby';
			match = '\b(abort|at_exit|autoload[?]?|binding|callcc|caller|caller_locations|chomp|chop|eval|exec|exit|exit!|fork|format|gets|global_variables|gsub|lambda|load|local_variables|open|p|print|printf|proc|putc|puts|rand|readline|readlines|select|set_trace_func|sleep|spawn|sprintf|srand|sub|syscall|system|test|trace_var|trap|untrace_var|warn)(\b|(?<=[?!]))(?![?!])';
		},
		{	name = 'variable.other.constant.ruby';
			match = '\b[_A-Z]\w*\b';
		},
		{	name = 'meta.function.method.with-arguments.ruby';
			comment = 'the method pattern comes from the symbol pattern, see there for a explaination';
			begin = '(?x)
			         (?=def\b)                                                      # an optimization to help Oniguruma fail fast
			         (?<=^|\s)(def)\s+                                              # the def keyword
			         ( (?>[a-zA-Z_]\w*(?>\.|::))?                                   # a method name prefix
			           (?>[a-zA-Z_]\w*(?>[?!]|=(?!>))?                              # the method name
			           |===?|!=|!~|>[>=]?|<=>|<[<=]?|[%&`/\|^]|\*\*?|=?~|[-+]@?|\[\]=?) )  # …or an operator method
			         \s*(\()                                                        # the openning parenthesis for arguments
			        ';
			end = '\)';
			beginCaptures = {
				1 = { name = 'keyword.control.def.ruby'; };
				2 = { name = 'entity.name.function.ruby'; };
				3 = { name = 'punctuation.definition.parameters.ruby'; };
			};
			endCaptures = { 0 = { name = 'punctuation.definition.parameters.ruby'; }; };
			patterns = (
				{	begin = '(?=[&*_a-zA-Z])';
					end = '(?=[,)])';
					patterns = (
						{	match = '\G([&*]?)(?:([_a-zA-Z]\w*(:))|([_a-zA-Z]\w*))';
							captures = {
								1 = { name = 'storage.type.variable.ruby'; };
								2 = { name = 'constant.other.symbol.hashkey.parameter.function.ruby'; };
								3 = { name = 'punctuation.definition.constant.ruby'; };
								4 = { name = 'variable.parameter.function.ruby'; };
							};
						},
						{	include = '#parens'; },
						{	include = '#braces'; },
						{	include = '$self'; },
					);
				},
			);
			repository = {
				braces = {
					begin = '\{';
					end = '\}';
					beginCaptures = { 0 = { name = 'punctuation.section.function.begin.ruby'; }; };
					endCaptures = { 0 = { name = 'punctuation.section.function.end.ruby'; }; };
					patterns = (
						{	include = '#parens'; },
						{	include = '#braces'; },
						{	include = '$self'; },
					);
				};
				parens = {
					begin = '\(';
					end = '\)';
					beginCaptures = { 0 = { name = 'punctuation.section.function.begin.ruby'; }; };
					endCaptures = { 0 = { name = 'punctuation.section.function.end.ruby'; }; };
					patterns = (
						{	include = '#parens'; },
						{	include = '#braces'; },
						{	include = '$self'; },
					);
				};
			};
		},
		{	name = 'meta.function.method.with-arguments.ruby';
			comment = 'same as the previous rule, but without parentheses around the arguments';
			begin = '(?x)
			         (?=def\b)                                                      # an optimization to help Oniguruma fail fast
			         (?<=^|\s)(def)\s+                                              # the def keyword
			         ( (?>[a-zA-Z_]\w*(?>\.|::))?                                   # a method name prefix
			           (?>[a-zA-Z_]\w*(?>[?!]|=(?!>))?                              # the method name
			           |===?|!=|!~|>[>=]?|<=>|<[<=]?|[%&`/\|^]|\*\*?|=?~|[-+]@?|\[\]=?) )  # …or an operator method
			         [ \t]                                                          # the space separating the arguments
			         (?=[ \t]*[^\s#;])                                              # make sure arguments and not a comment follow
			        ';
			end = '$';
			beginCaptures = {
				1 = { name = 'keyword.control.def.ruby'; };
				2 = { name = 'entity.name.function.ruby'; };
			};
			patterns = (
				{	begin = '(?![\s,])';
					end = '(?=,|$)';
					patterns = (
						{	name = 'variable.parameter.function.ruby';
							match = '\G([&*]?)(?:([_a-zA-Z]\w*(:))|([_a-zA-Z]\w*))';
							captures = {
								1 = { name = 'storage.type.variable.ruby'; };
								2 = { name = 'constant.other.symbol.hashkey.parameter.function.ruby'; };
								3 = { name = 'punctuation.definition.constant.ruby'; };
								4 = { name = 'variable.parameter.function.ruby'; };
							};
						},
						{	include = '$self'; },
					);
				},
			);
		},
		{	name = 'meta.function.method.without-arguments.ruby';
			comment = ' the optional name is just to catch the def also without a method-name';
			match = '(?x)
			         (?=def\b)                                                           # an optimization to help Oniguruma fail fast
			         (?<=^|\s)(def)\b                                                    # the def keyword
			         ( \s+                                                               # an optional group of whitespace followed by…
			           ( (?>[a-zA-Z_]\w*(?>\.|::))?                                      # a method name prefix
			             (?>[a-zA-Z_]\w*(?>[?!]|=(?!>))?                                 # the method name
			             |===?|!=|!~|>[>=]?|<=>|<[<=]?|[%&`/\|^]|\*\*?|=?~|[-+]@?|\[\]=?) ) )?  # …or an operator method
			        ';
			captures = {
				1 = { name = 'keyword.control.def.ruby'; };
				3 = { name = 'entity.name.function.ruby'; };
			};
		},
		{	name = 'constant.numeric.float.ruby';
			match = '\b\d(?>_?\d)*(?=\.\d|[eE])(\.\d(?>_?\d)*)?([eE][-+]?\d(?>_?\d)*)?r?i?\b';
		},
		{	name = 'constant.numeric.integer.ruby';
			match = '\b(0|(0[dD]\d|[1-9])(?>_?\d)*)r?i?\b';
		},
		{	name = 'constant.numeric.hex.ruby';
			match = '\b0[xX]\h(?>_?\h)*r?i?\b';
		},
		{	name = 'constant.numeric.binary.ruby';
			match = '\b0[bB][01](?>_?[01])*r?i?\b';
		},
		{	name = 'constant.numeric.octal.ruby';
			match = '\b0([oO]?[0-7](?>_?[0-7])*)?r?i?\b';
		},
		{	name = 'constant.other.symbol.single-quoted.ruby';
			begin = ":'";
			end = "'";
			captures = { 0 = { name = 'punctuation.definition.constant.ruby'; }; };
			patterns = (
				{	name = 'constant.character.escape.ruby';
					match = '\\[''\\]';
				},
			);
		},
		{	name = 'constant.other.symbol.double-quoted.ruby';
			begin = ':"';
			end = '"';
			captures = { 0 = { name = 'punctuation.definition.constant.ruby'; }; };
			patterns = (
				{	include = '#interpolated_ruby'; },
				{	include = '#escaped_char'; },
			);
		},
		{	name = 'keyword.operator.assignment.augmented.ruby';
			comment = 'Needs higher precidence than regular expressions.';
			match = '(?<!\()/=';
		},
		{	name = 'string.quoted.single.ruby';
			comment = 'single quoted string (does not allow interpolation)';
			begin = "'";
			end = "'";
			beginCaptures = { 0 = { name = 'punctuation.definition.string.begin.ruby'; }; };
			endCaptures = { 0 = { name = 'punctuation.definition.string.end.ruby'; }; };
			patterns = (
				{	name = 'constant.character.escape.ruby';
					match = '\\''|\\\\';
				},
			);
		},
		{	name = 'string.quoted.double.ruby';
			comment = 'double quoted string (allows for interpolation)';
			begin = '"';
			end = '"';
			beginCaptures = { 0 = { name = 'punctuation.definition.string.begin.ruby'; }; };
			endCaptures = { 0 = { name = 'punctuation.definition.string.end.ruby'; }; };
			patterns = (
				{	include = '#interpolated_ruby'; },
				{	include = '#escaped_char'; },
			);
		},
		{	name = 'string.interpolated.ruby';
			comment = 'execute string (allows for interpolation)';
			begin = '`';
			end = '`';
			beginCaptures = { 0 = { name = 'punctuation.definition.string.begin.ruby'; }; };
			endCaptures = { 0 = { name = 'punctuation.definition.string.end.ruby'; }; };
			patterns = (
				{	include = '#interpolated_ruby'; },
				{	include = '#escaped_char'; },
			);
		},
		{	include = '#percent_literals'; },
		{	comment = 'regular expressions (normal)
			we only start a regexp if the character before it (excluding whitespace)
			is what we think is before a regexp
			';
			begin = '(?x)
			   (?:
			     ^                      # beginning of line
			   | (?<=                   # or look-behind on:
			       [=>~(?:\[,|&;]
			     | [\s;]if\s			# keywords
			     | [\s;]elsif\s
			     | [\s;]while\s
			     | [\s;]unless\s
			     | [\s;]when\s
			     | [\s;]assert_match\s
			     | [\s;]or\s			# boolean opperators
			     | [\s;]and\s
			     | [\s;]not\s
			     | [\s.]index\s			# methods
			     | [\s.]scan\s
			     | [\s.]sub\s
			     | [\s.]sub!\s
			     | [\s.]gsub\s
			     | [\s.]gsub!\s
			     | [\s.]match\s
			     )
			   | (?<=                  # or a look-behind with line anchor:
			        ^when\s            # duplication necessary due to limits of regex
			      | ^if\s
			      | ^elsif\s
			      | ^while\s
			      | ^unless\s
			      )
			   )
			   \s*((/))(?![*+{}?])
			';
			end = '((/[eimnosux]*))';
			captures = {
				1 = { name = 'string.regexp.classic.ruby'; };
				2 = { name = 'punctuation.definition.string.ruby'; };
			};
			contentName = 'string.regexp.classic.ruby';
			patterns = ( { include = '#regex_sub'; } );
		},
		{	name = 'constant.other.symbol.ruby';
			comment = 'symbols';
			match = '(?<!:)(:)(?>[a-zA-Z_]\w*(?>[?!]|=(?![>=]))?|===?|>[>=]?|<=>|<[<=]?|[%&`/\|]|\*\*?|=?~|[-+]@?|\[\]=?|(@@?|\$)[a-zA-Z_]\w*)';
			captures = { 1 = { name = 'punctuation.definition.constant.ruby'; }; };
		},
		{	name = 'comment.block.documentation.ruby';
			comment = 'multiline comments';
			begin = '^=begin';
			end = '^=end';
			captures = { 0 = { name = 'punctuation.definition.comment.ruby'; }; };
		},
		{	begin = '(^[ \t]+)?(?=#)';
			end = '(?!\G)';
			beginCaptures = { 1 = { name = 'punctuation.whitespace.comment.leading.ruby'; }; };
			patterns = (
				{	name = 'comment.line.number-sign.ruby';
					begin = '#';
					end = '\n';
					beginCaptures = { 0 = { name = 'punctuation.definition.comment.ruby'; }; };
				},
			);
		},
		{	name = 'constant.numeric.ruby';
			comment = '
			matches questionmark-letters.

			examples (1st alternation = hex):
			?\x1     ?\x61

			examples (2nd alternation = octal):
			?\0      ?\07     ?\017

			examples (3rd alternation = escaped):
			?\n      ?\b

			examples (4th alternation = meta-ctrl):
			?\C-a    ?\M-a    ?\C-\M-\C-\M-a

			examples (4th alternation = normal):
			?a       ?A       ?0 
			?*       ?"       ?( 
			?.       ?#
			
			
			the negative lookbehind prevents against matching
			p(42.tainted?)
			';
			match = '(?<!\w)\?(\\(x\h{1,2}(?!\h)\b|0[0-7]{0,2}(?![0-7])\b|[^x0MC])|(\\[MC]-)+\w|[^\s\\])';
		},
		{	name = 'meta.embedded.block.html';
			comment = 'Heredoc with embedded html';
			begin = '(?=(?><<[-~]("?)((?:[_\w]+_|)HTML)\b\1))';
			end = '(?!\G)';
			patterns = (
				{	name = 'string.unquoted.heredoc.ruby';
					begin = '(?><<[-~]("?)((?:[_\w]+_|)HTML)\b\1)';
					end = '\s*\2$\n?';
					beginCaptures = { 0 = { name = 'punctuation.definition.string.begin.ruby'; }; };
					endCaptures = { 0 = { name = 'punctuation.definition.string.end.ruby'; }; };
					contentName = 'text.html';
					patterns = (
						{	include = '#heredoc'; },
						{	include = '#interpolated_ruby'; },
						{	include = 'text.html.basic'; },
						{	include = '#escaped_char'; },
					);
				},
			);
		},
		{	name = 'meta.embedded.block.xml';
			comment = 'Heredoc with embedded xml';
			begin = '(?=(?><<[-~]("?)((?:[_\w]+_|)XML)\b\1))';
			end = '(?!\G)';
			patterns = (
				{	name = 'string.unquoted.heredoc.ruby';
					begin = '(?><<[-~]("?)((?:[_\w]+_|)XML)\b\1)';
					end = '\s*\2$\n?';
					beginCaptures = { 0 = { name = 'punctuation.definition.string.begin.ruby'; }; };
					endCaptures = { 0 = { name = 'punctuation.definition.string.end.ruby'; }; };
					contentName = 'text.xml';
					patterns = (
						{	include = '#heredoc'; },
						{	include = '#interpolated_ruby'; },
						{	include = 'text.xml'; },
						{	include = '#escaped_char'; },
					);
				},
			);
		},
		{	name = 'meta.embedded.block.sql';
			comment = 'Heredoc with embedded sql';
			begin = '(?=(?><<[-~]("?)((?:[_\w]+_|)SQL)\b\1))';
			end = '(?!\G)';
			patterns = (
				{	name = 'string.unquoted.heredoc.ruby';
					begin = '(?><<[-~]("?)((?:[_\w]+_|)SQL)\b\1)';
					end = '\s*\2$\n?';
					beginCaptures = { 0 = { name = 'punctuation.definition.string.begin.ruby'; }; };
					endCaptures = { 0 = { name = 'punctuation.definition.string.end.ruby'; }; };
					contentName = 'source.sql';
					patterns = (
						{	include = '#heredoc'; },
						{	include = '#interpolated_ruby'; },
						{	include = 'source.sql'; },
						{	include = '#escaped_char'; },
					);
				},
			);
		},
		{	name = 'meta.embedded.block.css';
			comment = 'Heredoc with embedded css';
			begin = '(?=(?><<[-~]("?)((?:[_\w]+_|)CSS)\b\1))';
			end = '(?!\G)';
			patterns = (
				{	name = 'string.unquoted.heredoc.ruby';
					begin = '(?><<[-~]("?)((?:[_\w]+_|)CSS)\b\1)';
					end = '\s*\2$\n?';
					beginCaptures = { 0 = { name = 'punctuation.definition.string.begin.ruby'; }; };
					endCaptures = { 0 = { name = 'punctuation.definition.string.end.ruby'; }; };
					contentName = 'source.css';
					patterns = (
						{	include = '#heredoc'; },
						{	include = '#interpolated_ruby'; },
						{	include = 'source.css'; },
						{	include = '#escaped_char'; },
					);
				},
			);
		},
		{	name = 'meta.embedded.block.c++';
			comment = 'Heredoc with embedded c++';
			begin = '(?=(?><<[-~]("?)((?:[_\w]+_|)CPP)\b\1))';
			end = '(?!\G)';
			patterns = (
				{	name = 'string.unquoted.heredoc.ruby';
					begin = '(?><<[-~]("?)((?:[_\w]+_|)CPP)\b\1)';
					end = '\s*\2$\n?';
					beginCaptures = { 0 = { name = 'punctuation.definition.string.begin.ruby'; }; };
					endCaptures = { 0 = { name = 'punctuation.definition.string.end.ruby'; }; };
					contentName = 'source.c++';
					patterns = (
						{	include = '#heredoc'; },
						{	include = '#interpolated_ruby'; },
						{	include = 'source.c++'; },
						{	include = '#escaped_char'; },
					);
				},
			);
		},
		{	name = 'meta.embedded.block.c';
			comment = 'Heredoc with embedded c';
			begin = '(?=(?><<[-~]("?)((?:[_\w]+_|)C)\b\1))';
			end = '(?!\G)';
			patterns = (
				{	name = 'string.unquoted.heredoc.ruby';
					begin = '(?><<[-~]("?)((?:[_\w]+_|)C)\b\1)';
					end = '\s*\2$\n?';
					beginCaptures = { 0 = { name = 'punctuation.definition.string.begin.ruby'; }; };
					endCaptures = { 0 = { name = 'punctuation.definition.string.end.ruby'; }; };
					contentName = 'source.c';
					patterns = (
						{	include = '#heredoc'; },
						{	include = '#interpolated_ruby'; },
						{	include = 'source.c'; },
						{	include = '#escaped_char'; },
					);
				},
			);
		},
		{	name = 'meta.embedded.block.js';
			comment = 'Heredoc with embedded javascript';
			begin = '(?=(?><<[-~]("?)((?:[_\w]+_|)(?:JS|JAVASCRIPT))\b\1))';
			end = '(?!\G)';
			patterns = (
				{	name = 'string.unquoted.heredoc.ruby';
					begin = '(?><<[-~]("?)((?:[_\w]+_|)(?:JS|JAVASCRIPT))\b\1)';
					end = '\s*\2$\n?';
					beginCaptures = { 0 = { name = 'punctuation.definition.string.begin.ruby'; }; };
					endCaptures = { 0 = { name = 'punctuation.definition.string.end.ruby'; }; };
					contentName = 'source.js';
					patterns = (
						{	include = '#heredoc'; },
						{	include = '#interpolated_ruby'; },
						{	include = 'source.js'; },
						{	include = '#escaped_char'; },
					);
				},
			);
		},
		{	name = 'meta.embedded.block.js.jquery';
			comment = 'Heredoc with embedded jQuery javascript';
			begin = '(?=(?><<[-~]("?)((?:[_\w]+_|)JQUERY)\b\1))';
			end = '(?!\G)';
			patterns = (
				{	name = 'string.unquoted.heredoc.ruby';
					begin = '(?><<[-~]("?)((?:[_\w]+_|)JQUERY)\b\1)';
					end = '\s*\2$\n?';
					beginCaptures = { 0 = { name = 'punctuation.definition.string.begin.ruby'; }; };
					endCaptures = { 0 = { name = 'punctuation.definition.string.end.ruby'; }; };
					contentName = 'source.js.jquery';
					patterns = (
						{	include = '#heredoc'; },
						{	include = '#interpolated_ruby'; },
						{	include = 'source.js.jquery'; },
						{	include = '#escaped_char'; },
					);
				},
			);
		},
		{	name = 'meta.embedded.block.shell';
			comment = 'Heredoc with embedded shell';
			begin = '(?=(?><<[-~]("?)((?:[_\w]+_|)(?:SH|SHELL))\b\1))';
			end = '(?!\G)';
			patterns = (
				{	name = 'string.unquoted.heredoc.ruby';
					begin = '(?><<[-~]("?)((?:[_\w]+_|)(?:SH|SHELL))\b\1)';
					end = '\s*\2$\n?';
					beginCaptures = { 0 = { name = 'punctuation.definition.string.begin.ruby'; }; };
					endCaptures = { 0 = { name = 'punctuation.definition.string.end.ruby'; }; };
					contentName = 'source.shell';
					patterns = (
						{	include = '#heredoc'; },
						{	include = '#interpolated_ruby'; },
						{	include = 'source.shell'; },
						{	include = '#escaped_char'; },
					);
				},
			);
		},
		{	name = 'meta.embedded.block.lua';
			comment = 'Heredoc with embedded lua';
			begin = '(?=(?><<[-~]("?)((?:[_\w]+_|)LUA)\b\1))';
			end = '(?!\G)';
			patterns = (
				{	name = 'string.unquoted.heredoc.ruby';
					begin = '(?><<[-~]("?)((?:[_\w]+_|)LUA)\b\1)';
					end = '\s*\2$\n?';
					beginCaptures = { 0 = { name = 'punctuation.definition.string.begin.ruby'; }; };
					endCaptures = { 0 = { name = 'punctuation.definition.string.end.ruby'; }; };
					contentName = 'source.lua';
					patterns = (
						{	include = '#heredoc'; },
						{	include = '#interpolated_ruby'; },
						{	include = 'source.lua'; },
						{	include = '#escaped_char'; },
					);
				},
			);
		},
		{	name = 'meta.embedded.block.ruby';
			comment = 'Heredoc with embedded ruby';
			begin = '(?=(?><<[-~]("?)((?:[_\w]+_|)RUBY)\b\1))';
			end = '(?!\G)';
			patterns = (
				{	name = 'string.unquoted.heredoc.ruby';
					begin = '(?><<[-~]("?)((?:[_\w]+_|)RUBY)\b\1)';
					end = '\s*\2$\n?';
					beginCaptures = { 0 = { name = 'punctuation.definition.string.begin.ruby'; }; };
					endCaptures = { 0 = { name = 'punctuation.definition.string.end.ruby'; }; };
					contentName = 'source.ruby';
					patterns = (
						{	include = '#heredoc'; },
						{	include = '#interpolated_ruby'; },
						{	include = 'source.ruby'; },
						{	include = '#escaped_char'; },
					);
				},
			);
		},
		{	name = 'string.unquoted.heredoc.ruby';
			begin = '(?>=\s*<<(\w+))';
			end = '^\1$';
			beginCaptures = { 0 = { name = 'punctuation.definition.string.begin.ruby'; }; };
			endCaptures = { 0 = { name = 'punctuation.definition.string.end.ruby'; }; };
			patterns = (
				{	include = '#heredoc'; },
				{	include = '#interpolated_ruby'; },
				{	include = '#escaped_char'; },
			);
		},
		{	name = 'string.unquoted.heredoc.ruby';
			comment = 'heredoc with indented terminator';
			begin = '(?><<[-~](\w+))';
			end = '\s*\1$';
			beginCaptures = { 0 = { name = 'punctuation.definition.string.begin.ruby'; }; };
			endCaptures = { 0 = { name = 'punctuation.definition.string.end.ruby'; }; };
			patterns = (
				{	include = '#heredoc'; },
				{	include = '#interpolated_ruby'; },
				{	include = '#escaped_char'; },
			);
		},
		{	begin = '(?<=\{|do|\{\s|do\s)(\|)';
			end = '(?<!\|)(\|)(?!\|)';
			captures = { 1 = { name = 'punctuation.separator.arguments.ruby'; }; };
			patterns = (
				{	include = '$self'; },
				{	name = 'variable.other.block.ruby';
					match = '[_a-zA-Z][_a-zA-Z0-9]*';
				},
				{	name = 'punctuation.separator.variable.ruby';
					match = ',';
				},
			);
		},
		{	name = 'punctuation.separator.key-value';
			match = '=>';
		},
		{	name = 'support.function.kernel.lambda.ruby';
			match = '->';
		},
		{	name = 'keyword.operator.assignment.augmented.ruby';
			match = '<<=|%=|&{1,2}=|\*=|\*\*=|\+=|-=|\^=|\|{1,2}=|<<';
		},
		{	name = 'keyword.operator.comparison.ruby';
			match = '<=>|<(?!<|=)|>(?!<|=|>)|<=|>=|===|==|=~|!=|!~|(?<=[ \t])\?';
		},
		{	name = 'keyword.operator.logical.ruby';
			match = '(?<!\.)\b(and|not|or)\b(?![?!])';
		},
		{	name = 'keyword.operator.logical.ruby';
			comment = 'Make sure this goes after assignment and comparison';
			match = '(?<=^|[ \t])!|&&|\|\||\^';
		},
		{	comment = 'Safe navigation operator - Added in 2.3';
			match = '(&\.)\s*(?![A-Z])';
			captures = { 1 = { name = 'punctuation.separator.method.ruby'; }; };
		},
		{	name = 'keyword.operator.arithmetic.ruby';
			match = '(%|&|\*\*|\*|\+|-|/)';
		},
		{	name = 'keyword.operator.assignment.ruby';
			match = '=';
		},
		{	name = 'keyword.operator.other.ruby';
			match = '\||~|>>';
		},
		{	name = 'punctuation.separator.statement.ruby';
			match = ';';
		},
		{	name = 'punctuation.separator.object.ruby';
			match = ',';
		},
		{	comment = 'Mark as namespace separator if double colons followed by capital letter';
			match = '(::)\s*(?=[A-Z])';
			captures = { 1 = { name = 'punctuation.separator.namespace.ruby'; }; };
		},
		{	comment = 'Mark as method separator if double colons not followed by capital letter';
			match = '(\.|::)\s*(?![A-Z])';
			captures = { 1 = { name = 'punctuation.separator.method.ruby'; }; };
		},
		{	name = 'punctuation.separator.other.ruby';
			comment = 'Must come after method and constant separators to prefer double colons';
			match = ':';
		},
		{	name = 'punctuation.section.scope.begin.ruby';
			match = '\{';
		},
		{	name = 'punctuation.section.scope.end.ruby';
			match = '\}';
		},
		{	name = 'punctuation.section.array.begin.ruby';
			match = '\[';
		},
		{	name = 'punctuation.section.array.end.ruby';
			match = '\]';
		},
		{	name = 'punctuation.section.function.ruby';
			match = '\(|\)';
		},
	);
	repository = {
		escaped_char = {
			name = 'constant.character.escape.ruby';
			match = '\\(?:[0-7]{1,3}|x[\da-fA-F]{1,2}|.)';
		};
		heredoc = {
			begin = '^<<[-~]?\w+';
			end = '$';
			patterns = ( { include = '$self'; } );
		};
		interpolated_ruby = {
			patterns = (
				{	name = 'meta.embedded.line.ruby';
					begin = '#\{';
					end = '(\})';
					beginCaptures = { 0 = { name = 'punctuation.section.embedded.begin.ruby'; }; };
					endCaptures = {
						0 = { name = 'punctuation.section.embedded.end.ruby'; };
						1 = { name = 'source.ruby'; };
					};
					contentName = 'source.ruby';
					patterns = (
						{	include = '#nest_curly_and_self'; },
						{	include = '$self'; },
					);
					repository = {
						nest_curly_and_self = {
							patterns = (
								{	begin = '\{';
									end = '\}';
									captures = { 0 = { name = 'punctuation.section.scope.ruby'; }; };
									patterns = ( { include = '#nest_curly_and_self'; } );
								},
								{	include = '$self'; },
							);
						};
					};
				},
				{	name = 'variable.other.readwrite.instance.ruby';
					match = '(#@)[a-zA-Z_]\w*';
					captures = { 1 = { name = 'punctuation.definition.variable.ruby'; }; };
				},
				{	name = 'variable.other.readwrite.class.ruby';
					match = '(#@@)[a-zA-Z_]\w*';
					captures = { 1 = { name = 'punctuation.definition.variable.ruby'; }; };
				},
				{	name = 'variable.other.readwrite.global.ruby';
					match = '(#\$)[a-zA-Z_]\w*';
					captures = { 1 = { name = 'punctuation.definition.variable.ruby'; }; };
				},
			);
		};
		percent_literals = {
			patterns = (
				{	name = 'meta.array.symbol.ruby';
					begin = '%i(?:([(\[{<])|([^\w\s]|_))';
					end = '[)\]}>]\2|\1\2';
					beginCaptures = { 0 = { name = 'punctuation.section.array.begin.ruby'; }; };
					endCaptures = { 0 = { name = 'punctuation.section.array.end.ruby'; }; };
					patterns = (
						{	begin = '\G(?<=\()(?!\))';
							end = '(?=\))';
							patterns = (
								{	include = '#parens'; },
								{	include = '#symbol'; },
							);
						},
						{	begin = '\G(?<=\[)(?!\])';
							end = '(?=\])';
							patterns = (
								{	include = '#brackets'; },
								{	include = '#symbol'; },
							);
						},
						{	begin = '\G(?<=\{)(?!\})';
							end = '(?=\})';
							patterns = (
								{	include = '#braces'; },
								{	include = '#symbol'; },
							);
						},
						{	begin = '\G(?<=<)(?!>)';
							end = '(?=>)';
							patterns = (
								{	include = '#angles'; },
								{	include = '#symbol'; },
							);
						},
						{	include = '#symbol'; },
					);
					repository = {
						angles = {
							patterns = (
								{	name = 'constant.other.symbol.ruby';
									match = '\\<|\\>';
									captures = { 0 = { name = 'constant.character.escape.ruby'; }; };
								},
								{	begin = '<';
									end = '>';
									captures = { 0 = { name = 'constant.other.symbol.ruby'; }; };
									patterns = (
										{	include = '#angles'; },
										{	include = '#symbol'; },
									);
								},
							);
						};
						braces = {
							patterns = (
								{	name = 'constant.other.symbol.ruby';
									match = '\\\{|\\\}';
									captures = { 0 = { name = 'constant.character.escape.ruby'; }; };
								},
								{	begin = '\{';
									end = '\}';
									captures = { 0 = { name = 'constant.other.symbol.ruby'; }; };
									patterns = (
										{	include = '#braces'; },
										{	include = '#symbol'; },
									);
								},
							);
						};
						brackets = {
							patterns = (
								{	name = 'constant.other.symbol.ruby';
									match = '\\\[|\\\]';
									captures = { 0 = { name = 'constant.character.escape.ruby'; }; };
								},
								{	begin = '\[';
									end = '\]';
									captures = { 0 = { name = 'constant.other.symbol.ruby'; }; };
									patterns = (
										{	include = '#brackets'; },
										{	include = '#symbol'; },
									);
								},
							);
						};
						parens = {
							patterns = (
								{	name = 'constant.other.symbol.ruby';
									match = '\\\(|\\\)';
									captures = { 0 = { name = 'constant.character.escape.ruby'; }; };
								},
								{	begin = '\(';
									end = '\)';
									captures = { 0 = { name = 'constant.other.symbol.ruby'; }; };
									patterns = (
										{	include = '#parens'; },
										{	include = '#symbol'; },
									);
								},
							);
						};
						symbol = {
							patterns = (
								{	name = 'constant.other.symbol.ruby';
									match = '\\\\|\\[ ]';
									captures = { 0 = { name = 'constant.character.escape.ruby'; }; };
								},
								{	name = 'constant.other.symbol.ruby';
									match = '\S\w*';
								},
							);
						};
					};
				},
				{	name = 'meta.array.symbol.interpolated.ruby';
					begin = '%I(?:([(\[{<])|([^\w\s]|_))';
					end = '[)\]}>]\2|\1\2';
					beginCaptures = { 0 = { name = 'punctuation.section.array.begin.ruby'; }; };
					endCaptures = { 0 = { name = 'punctuation.section.array.end.ruby'; }; };
					patterns = (
						{	begin = '\G(?<=\()(?!\))';
							end = '(?=\))';
							patterns = (
								{	include = '#parens'; },
								{	include = '#symbol'; },
							);
						},
						{	begin = '\G(?<=\[)(?!\])';
							end = '(?=\])';
							patterns = (
								{	include = '#brackets'; },
								{	include = '#symbol'; },
							);
						},
						{	begin = '\G(?<=\{)(?!\})';
							end = '(?=\})';
							patterns = (
								{	include = '#braces'; },
								{	include = '#symbol'; },
							);
						},
						{	begin = '\G(?<=<)(?!>)';
							end = '(?=>)';
							patterns = (
								{	include = '#angles'; },
								{	include = '#symbol'; },
							);
						},
						{	include = '#symbol'; },
					);
					repository = {
						angles = {
							patterns = (
								{	begin = '<';
									end = '>';
									captures = { 0 = { name = 'constant.other.symbol.ruby'; }; };
									patterns = (
										{	include = '#angles'; },
										{	include = '#symbol'; },
									);
								},
							);
						};
						braces = {
							patterns = (
								{	begin = '\{';
									end = '\}';
									captures = { 0 = { name = 'constant.other.symbol.ruby'; }; };
									patterns = (
										{	include = '#braces'; },
										{	include = '#symbol'; },
									);
								},
							);
						};
						brackets = {
							patterns = (
								{	begin = '\[';
									end = '\]';
									captures = { 0 = { name = 'constant.other.symbol.ruby'; }; };
									patterns = (
										{	include = '#brackets'; },
										{	include = '#symbol'; },
									);
								},
							);
						};
						parens = {
							patterns = (
								{	begin = '\(';
									end = '\)';
									captures = { 0 = { name = 'constant.other.symbol.ruby'; }; };
									patterns = (
										{	include = '#parens'; },
										{	include = '#symbol'; },
									);
								},
							);
						};
						symbol = {
							patterns = (
								{	name = 'constant.other.symbol.ruby';
									begin = '(?=\\|#\{)';
									end = '(?!\G)';
									patterns = (
										{	include = '#escaped_char'; },
										{	include = '#interpolated_ruby'; },
									);
								},
								{	name = 'constant.other.symbol.ruby';
									match = '\S\w*';
								},
							);
						};
					};
				},
				{	name = 'string.quoted.other.ruby';
					begin = '%q(?:([(\[{<])|([^\w\s]|_))';
					end = '[)\]}>]\2|\1\2';
					beginCaptures = { 0 = { name = 'punctuation.definition.string.begin.ruby'; }; };
					endCaptures = { 0 = { name = 'punctuation.definition.string.end.ruby'; }; };
					patterns = (
						{	begin = '\G(?<=\()(?!\))';
							end = '(?=\))';
							patterns = ( { include = '#parens'; } );
						},
						{	begin = '\G(?<=\[)(?!\])';
							end = '(?=\])';
							patterns = ( { include = '#brackets'; } );
						},
						{	begin = '\G(?<=\{)(?!\})';
							end = '(?=\})';
							patterns = ( { include = '#braces'; } );
						},
						{	begin = '\G(?<=<)(?!>)';
							end = '(?=>)';
							patterns = ( { include = '#angles'; } );
						},
					);
					repository = {
						angles = {
							patterns = (
								{	name = 'constant.character.escape.ruby';
									match = '\\<|\\>|\\\\';
								},
								{	begin = '<';
									end = '>';
									patterns = ( { include = '#angles'; } );
								},
							);
						};
						braces = {
							patterns = (
								{	name = 'constant.character.escape.ruby';
									match = '\\\{|\\\}|\\\\';
								},
								{	begin = '\{';
									end = '\}';
									patterns = ( { include = '#braces'; } );
								},
							);
						};
						brackets = {
							patterns = (
								{	name = 'constant.character.escape.ruby';
									match = '\\\[|\\\]|\\\\';
								},
								{	begin = '\[';
									end = '\]';
									patterns = ( { include = '#brackets'; } );
								},
							);
						};
						parens = {
							patterns = (
								{	name = 'constant.character.escape.ruby';
									match = '\\\(|\\\)|\\\\';
								},
								{	begin = '\(';
									end = '\)';
									patterns = ( { include = '#parens'; } );
								},
							);
						};
					};
				},
				{	name = 'string.quoted.other.interpolated.ruby';
					begin = '%Q?(?:([(\[{<])|([^\w\s=]|_))';
					end = '[)\]}>]\2|\1\2';
					beginCaptures = { 0 = { name = 'punctuation.definition.string.begin.ruby'; }; };
					endCaptures = { 0 = { name = 'punctuation.definition.string.end.ruby'; }; };
					patterns = (
						{	begin = '\G(?<=\()(?!\))';
							end = '(?=\))';
							patterns = ( { include = '#parens'; } );
						},
						{	begin = '\G(?<=\[)(?!\])';
							end = '(?=\])';
							patterns = ( { include = '#brackets'; } );
						},
						{	begin = '\G(?<=\{)(?!\})';
							end = '(?=\})';
							patterns = ( { include = '#braces'; } );
						},
						{	begin = '\G(?<=<)(?!>)';
							end = '(?=>)';
							patterns = ( { include = '#angles'; } );
						},
						{	include = '#escaped_char'; },
						{	include = '#interpolated_ruby'; },
					);
					repository = {
						angles = {
							patterns = (
								{	include = '#escaped_char'; },
								{	include = '#interpolated_ruby'; },
								{	begin = '<';
									end = '>';
									patterns = ( { include = '#angles'; } );
								},
							);
						};
						braces = {
							patterns = (
								{	include = '#escaped_char'; },
								{	include = '#interpolated_ruby'; },
								{	begin = '\{';
									end = '\}';
									patterns = ( { include = '#braces'; } );
								},
							);
						};
						brackets = {
							patterns = (
								{	include = '#escaped_char'; },
								{	include = '#interpolated_ruby'; },
								{	begin = '\[';
									end = '\]';
									patterns = ( { include = '#brackets'; } );
								},
							);
						};
						parens = {
							patterns = (
								{	include = '#escaped_char'; },
								{	include = '#interpolated_ruby'; },
								{	begin = '\(';
									end = '\)';
									patterns = ( { include = '#parens'; } );
								},
							);
						};
					};
				},
				{	name = 'string.regexp.percent.ruby';
					begin = '%r(?:([(\[{<])|([^\w\s]|_))';
					end = '([)\]}>]\2|\1\2)[eimnosux]*';
					beginCaptures = { 0 = { name = 'punctuation.definition.string.begin.ruby'; }; };
					endCaptures = { 0 = { name = 'punctuation.definition.string.end.ruby'; }; };
					patterns = (
						{	begin = '\G(?<=\()(?!\))';
							end = '(?=\))';
							patterns = ( { include = '#parens'; } );
						},
						{	begin = '\G(?<=\[)(?!\])';
							end = '(?=\])';
							patterns = ( { include = '#brackets'; } );
						},
						{	begin = '\G(?<=\{)(?!\})';
							end = '(?=\})';
							patterns = ( { include = '#braces'; } );
						},
						{	begin = '\G(?<=<)(?!>)';
							end = '(?=>)';
							patterns = ( { include = '#angles'; } );
						},
						{	include = '#regex_sub'; },
					);
					repository = {
						angles = {
							patterns = (
								{	include = '#regex_sub'; },
								{	begin = '<';
									end = '>';
									patterns = ( { include = '#angles'; } );
								},
							);
						};
						braces = {
							patterns = (
								{	include = '#regex_sub'; },
								{	begin = '\{';
									end = '\}';
									patterns = ( { include = '#braces'; } );
								},
							);
						};
						brackets = {
							patterns = (
								{	include = '#regex_sub'; },
								{	begin = '\[';
									end = '\]';
									patterns = ( { include = '#brackets'; } );
								},
							);
						};
						parens = {
							patterns = (
								{	include = '#regex_sub'; },
								{	begin = '\(';
									end = '\)';
									patterns = ( { include = '#parens'; } );
								},
							);
						};
					};
				},
				{	name = 'constant.other.symbol.percent.ruby';
					begin = '%s(?:([(\[{<])|([^\w\s]|_))';
					end = '[)\]}>]\2|\1\2';
					beginCaptures = { 0 = { name = 'punctuation.definition.constant.begin.ruby'; }; };
					endCaptures = { 0 = { name = 'punctuation.definition.constant.end.ruby'; }; };
					patterns = (
						{	begin = '\G(?<=\()(?!\))';
							end = '(?=\))';
							patterns = ( { include = '#parens'; } );
						},
						{	begin = '\G(?<=\[)(?!\])';
							end = '(?=\])';
							patterns = ( { include = '#brackets'; } );
						},
						{	begin = '\G(?<=\{)(?!\})';
							end = '(?=\})';
							patterns = ( { include = '#braces'; } );
						},
						{	begin = '\G(?<=<)(?!>)';
							end = '(?=>)';
							patterns = ( { include = '#angles'; } );
						},
					);
					repository = {
						angles = {
							patterns = (
								{	name = 'constant.character.escape.ruby';
									match = '\\<|\\>|\\\\';
								},
								{	begin = '<';
									end = '>';
									patterns = ( { include = '#angles'; } );
								},
							);
						};
						braces = {
							patterns = (
								{	name = 'constant.character.escape.ruby';
									match = '\\\{|\\\}|\\\\';
								},
								{	begin = '\{';
									end = '\}';
									patterns = ( { include = '#braces'; } );
								},
							);
						};
						brackets = {
							patterns = (
								{	name = 'constant.character.escape.ruby';
									match = '\\\[|\\\]|\\\\';
								},
								{	begin = '\[';
									end = '\]';
									patterns = ( { include = '#brackets'; } );
								},
							);
						};
						parens = {
							patterns = (
								{	name = 'constant.character.escape.ruby';
									match = '\\\(|\\\)|\\\\';
								},
								{	begin = '\(';
									end = '\)';
									patterns = ( { include = '#parens'; } );
								},
							);
						};
					};
				},
				{	name = 'meta.array.string.ruby';
					begin = '%w(?:([(\[{<])|([^\w\s]|_))';
					end = '[)\]}>]\2|\1\2';
					beginCaptures = { 0 = { name = 'punctuation.section.array.begin.ruby'; }; };
					endCaptures = { 0 = { name = 'punctuation.section.array.end.ruby'; }; };
					patterns = (
						{	begin = '\G(?<=\()(?!\))';
							end = '(?=\))';
							patterns = (
								{	include = '#parens'; },
								{	include = '#string'; },
							);
						},
						{	begin = '\G(?<=\[)(?!\])';
							end = '(?=\])';
							patterns = (
								{	include = '#brackets'; },
								{	include = '#string'; },
							);
						},
						{	begin = '\G(?<=\{)(?!\})';
							end = '(?=\})';
							patterns = (
								{	include = '#braces'; },
								{	include = '#string'; },
							);
						},
						{	begin = '\G(?<=<)(?!>)';
							end = '(?=>)';
							patterns = (
								{	include = '#angles'; },
								{	include = '#string'; },
							);
						},
						{	include = '#string'; },
					);
					repository = {
						angles = {
							patterns = (
								{	name = 'string.other.ruby';
									match = '\\<|\\>';
									captures = { 0 = { name = 'constant.character.escape.ruby'; }; };
								},
								{	begin = '<';
									end = '>';
									captures = { 0 = { name = 'string.other.ruby'; }; };
									patterns = (
										{	include = '#angles'; },
										{	include = '#string'; },
									);
								},
							);
						};
						braces = {
							patterns = (
								{	name = 'string.other.ruby';
									match = '\\\{|\\\}';
									captures = { 0 = { name = 'constant.character.escape.ruby'; }; };
								},
								{	begin = '\{';
									end = '\}';
									captures = { 0 = { name = 'string.other.ruby'; }; };
									patterns = (
										{	include = '#braces'; },
										{	include = '#string'; },
									);
								},
							);
						};
						brackets = {
							patterns = (
								{	name = 'string.other.ruby';
									match = '\\\[|\\\]';
									captures = { 0 = { name = 'constant.character.escape.ruby'; }; };
								},
								{	begin = '\[';
									end = '\]';
									captures = { 0 = { name = 'string.other.ruby'; }; };
									patterns = (
										{	include = '#brackets'; },
										{	include = '#string'; },
									);
								},
							);
						};
						parens = {
							patterns = (
								{	name = 'string.other.ruby';
									match = '\\\(|\\\)';
									captures = { 0 = { name = 'constant.character.escape.ruby'; }; };
								},
								{	begin = '\(';
									end = '\)';
									captures = { 0 = { name = 'string.other.ruby'; }; };
									patterns = (
										{	include = '#parens'; },
										{	include = '#string'; },
									);
								},
							);
						};
						string = {
							patterns = (
								{	name = 'string.other.ruby';
									match = '\\\\|\\[ ]';
									captures = { 0 = { name = 'constant.character.escape.ruby'; }; };
								},
								{	name = 'string.other.ruby';
									match = '\S\w*';
								},
							);
						};
					};
				},
				{	name = 'meta.array.string.interpolated.ruby';
					begin = '%W(?:([(\[{<])|([^\w\s]|_))';
					end = '[)\]}>]\2|\1\2';
					beginCaptures = { 0 = { name = 'punctuation.section.array.begin.ruby'; }; };
					endCaptures = { 0 = { name = 'punctuation.section.array.end.ruby'; }; };
					patterns = (
						{	begin = '\G(?<=\()(?!\))';
							end = '(?=\))';
							patterns = (
								{	include = '#parens'; },
								{	include = '#string'; },
							);
						},
						{	begin = '\G(?<=\[)(?!\])';
							end = '(?=\])';
							patterns = (
								{	include = '#brackets'; },
								{	include = '#string'; },
							);
						},
						{	begin = '\G(?<=\{)(?!\})';
							end = '(?=\})';
							patterns = (
								{	include = '#braces'; },
								{	include = '#string'; },
							);
						},
						{	begin = '\G(?<=<)(?!>)';
							end = '(?=>)';
							patterns = (
								{	include = '#angles'; },
								{	include = '#string'; },
							);
						},
						{	include = '#string'; },
					);
					repository = {
						angles = {
							patterns = (
								{	begin = '<';
									end = '>';
									captures = { 0 = { name = 'string.other.ruby'; }; };
									patterns = (
										{	include = '#angles'; },
										{	include = '#string'; },
									);
								},
							);
						};
						braces = {
							patterns = (
								{	begin = '\{';
									end = '\}';
									captures = { 0 = { name = 'string.other.ruby'; }; };
									patterns = (
										{	include = '#braces'; },
										{	include = '#string'; },
									);
								},
							);
						};
						brackets = {
							patterns = (
								{	begin = '\[';
									end = '\]';
									captures = { 0 = { name = 'string.other.ruby'; }; };
									patterns = (
										{	include = '#brackets'; },
										{	include = '#string'; },
									);
								},
							);
						};
						parens = {
							patterns = (
								{	begin = '\(';
									end = '\)';
									captures = { 0 = { name = 'string.other.ruby'; }; };
									patterns = (
										{	include = '#parens'; },
										{	include = '#string'; },
									);
								},
							);
						};
						string = {
							patterns = (
								{	name = 'string.other.ruby';
									begin = '(?=\\|#\{)';
									end = '(?!\G)';
									patterns = (
										{	include = '#escaped_char'; },
										{	include = '#interpolated_ruby'; },
									);
								},
								{	name = 'string.other.ruby';
									match = '\S\w*';
								},
							);
						};
					};
				},
				{	name = 'string.interpolated.percent.ruby';
					begin = '%x(?:([(\[{<])|([^\w\s]|_))';
					end = '[)\]}>]\2|\1\2';
					beginCaptures = { 0 = { name = 'punctuation.definition.string.begin.ruby'; }; };
					endCaptures = { 0 = { name = 'punctuation.definition.string.end.ruby'; }; };
					patterns = (
						{	begin = '\G(?<=\()(?!\))';
							end = '(?=\))';
							patterns = ( { include = '#parens'; } );
						},
						{	begin = '\G(?<=\[)(?!\])';
							end = '(?=\])';
							patterns = ( { include = '#brackets'; } );
						},
						{	begin = '\G(?<=\{)(?!\})';
							end = '(?=\})';
							patterns = ( { include = '#braces'; } );
						},
						{	begin = '\G(?<=<)(?!>)';
							end = '(?=>)';
							patterns = ( { include = '#angles'; } );
						},
						{	include = '#escaped_char'; },
						{	include = '#interpolated_ruby'; },
					);
					repository = {
						angles = {
							patterns = (
								{	include = '#escaped_char'; },
								{	include = '#interpolated_ruby'; },
								{	begin = '<';
									end = '>';
									patterns = ( { include = '#angles'; } );
								},
							);
						};
						braces = {
							patterns = (
								{	include = '#escaped_char'; },
								{	include = '#interpolated_ruby'; },
								{	begin = '\{';
									end = '\}';
									patterns = ( { include = '#braces'; } );
								},
							);
						};
						brackets = {
							patterns = (
								{	include = '#escaped_char'; },
								{	include = '#interpolated_ruby'; },
								{	begin = '\[';
									end = '\]';
									patterns = ( { include = '#brackets'; } );
								},
							);
						};
						parens = {
							patterns = (
								{	include = '#escaped_char'; },
								{	include = '#interpolated_ruby'; },
								{	begin = '\(';
									end = '\)';
									patterns = ( { include = '#parens'; } );
								},
							);
						};
					};
				},
			);
		};
		regex_sub = {
			patterns = (
				{	include = '#interpolated_ruby'; },
				{	include = '#escaped_char'; },
				{	name = 'keyword.operator.quantifier.ruby';
					match = '(\{)\d+(,\d+)?(\})';
					captures = {
						1 = { name = 'punctuation.definition.quantifier.begin.ruby'; };
						3 = { name = 'punctuation.definition.quantifier.end.ruby'; };
					};
				},
				{	name = 'constant.other.character-class.set.ruby';
					begin = '\[\^?';
					end = '\]';
					beginCaptures = { 0 = { name = 'punctuation.definition.character-class.begin.ruby'; }; };
					endCaptures = { 0 = { name = 'punctuation.definition.character-class.end.ruby'; }; };
					patterns = ( { include = '#escaped_char'; } );
				},
				{	name = 'comment.line.number-sign.ruby';
					begin = '\(\?#';
					end = '\)';
					beginCaptures = { 0 = { name = 'punctuation.definition.comment.begin.ruby'; }; };
					endCaptures = { 0 = { name = 'punctuation.definition.comment.end.ruby'; }; };
					patterns = ( { include = '#escaped_char'; } );
				},
				{	name = 'meta.group.regexp.ruby';
					begin = '\(';
					end = '\)';
					captures = { 0 = { name = 'punctuation.definition.group.ruby'; }; };
					patterns = ( { include = '#regex_sub'; } );
				},
				{	name = 'comment.line.number-sign.ruby';
					comment = 'We are restrictive in what we allow to go after the comment character to avoid false positives, since the availability of comments depend on regexp flags.';
					begin = '(?<=^|\s)(#)\s(?=[[a-zA-Z0-9,. \t?!-][^\x{00}-\x{7F}]]*$)';
					end = '$\n?';
					beginCaptures = { 1 = { name = 'punctuation.definition.comment.ruby'; }; };
				},
			);
		};
	};
}